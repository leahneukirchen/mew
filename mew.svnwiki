Mew is a library targetting R5RS/R7RS scheme, which provides some
conveniences inspired from Goo, Clojure, T and Arc to allow writing more
compact code.


== Design goals

Mew, in its current iteration, is designed as a Scheme library.  Even
though a program written in Mew will look quite different to a plain
Scheme program, code is compatible, and Scheme code can generally live
inside a Mew program, and Mew can load Scheme libraries.  Extra care
has been taken to not reuse identifiers found in important SRFIs.

Mew code is tight code, commonly used Mew identifiers are short.

Mew uses a few features provided by R7RS internally, but does not
require using R7RS.

Mew targets Chicken Scheme currently but should be easy to port to
other Scheme implementations.

Mew is multi-paradigm: it simplifies both writing imperative and
functional code.

Mew uses SRFI-158 (Generators and Accumulators) for generic functions
on enumerable structures.

Mew generally uses {{equal?}} as equality predicate.

Mew never mutates lists.

Except for few shortcut macros ({{op}} and {{op*}),
Mew endorses macro hygiene.


== Re-Exports

Mew re-exports
SRFI-1 (List library),
SRFI-13 (String Libraries) (from {{utf8-srfi-13}}),
SRFI-69 (Basic hash tables),
SRFI-158 (Generators and Accumulators),
{{(chicken io)}},
{{(chicken irregex)}},
{{(chicken pretty-print)}}},
{{(chicken sort)}}},
{{matchable}},
and {{err}} (see {{err.svnwiki}}).


== Definitions, bindings and assignments

<syntax>(def <variable> <expression>)</syntax>
<syntax>(def (<variable> <formals>) <expression>)</syntax>

Alias for {{define}}.

<syntax>(fun <formals> <body>...)</syntax>

Alias for {{lambda}}.

<syntax>(fun* <pattern> <body>...)</syntax>

Lambda which pattern matches all its arguments (ala the {{match}} macro).

<syntax>(loc (<pat1> <val1> ... <patN> <valN>) <body>)</syntax>

Binds local variables in pattern (ala the {{match}} macro)
{{pat1}} to the result of evaluating {{val1}},
then {{pat2}} to {{val2}}, etc., then evaluates {{body}}.

Assignments can refer to previously assigned values of the {{loc}}.

<syntax>(andloc (<var1> <val1> ... <varN> <valN>) <body>)</syntax>

Like {{loc}} (without pattern matching), but return false when one of
the {{<valN>>}} evaluates to false.  If a {{<valN>}} is {{_}},
only performs the check without binding a value.

<syntax>(rec <name> <expression>)</syntax>
<syntax>(rec (<name> <formals>) <expression>)</syntax>

See Module%20(chicken%20base)#rec or SRFI-31.

Often, using {{def}} in an inner scope is preferable to using {{rec}}.

<syntax>(set <location> <expression>)</syntax>

Like {{set!}}, but also return the value of {{<expression>}}.


== Control flow

<syntax>(esc <escape> <body>)</syntax>

Bind {{<escape>}} to the current continuation, then run {{<body>}}.
Code should not pass {{<escape>}} outside the lexical scope
and only call it once---use {{call/cc}} else.

<syntax>(fin <body> . <cleanup>)</syntax>

Evaluate {{<body>}}, then evaluate {{<cleanup>}}, even if {{<body>}}
used a non-local exit (as from {{esc}}).

Returns value of {{<body>}}, so can also be used as a replacment
for Common Lisp PROG1.

<syntax>(rep <name> (<var1> <init1> ... <varN> <initN>) <body>...)</syntax>

Explicit form of named {{let}}, using {{loc}} binding syntax.

Assignments cannot refer to previously assigned values of the {{rep}}.

<syntax>(seq . <body>)</syntax>

Like {{begin}}, but allows {{<body>}} to be empty and returns a value
which is {{void?}} then.

<syntax>(unless <cond> <expr>...)</syntax>
<syntax>(when <cond> <expr>...)</syntax>

As in R7RS-small.

<syntax>(while <cond> <expr>...)</syntax>
<syntax>(until <cond> <expr>...)</syntax>

Evaluate {{<expr>}} while {{<cond>}} is true/false.

<syntax>(xcond <cases>...)<syntax>

Like {{cond}}, but raise error if no case matched.

<syntax>(fail <type>? <message> <args>...)</syntax>

Create and signal a condition of {{<type>}} (default: {{(exn)}})
with a {{'message}} of {{<message>}} passed through {{format}} with
{{<args>}}.


== Numeric helpers

<procedure>(inc <num>)</procedure>
<procedure>(dec <num>)</procedure>

Increment or decrement the argument by 1.

<procedure>(div <num> <num>)</procedure>

Alias for {{floor-quotient}}.

<procedure>(mod <num> <num>)</procedure>

Alias for {{floor-remainder}}.


== General helpers

<procedure>(app <proc> . <args>)</procedure>

Alias for {{apply}}.

<syntax>(op <form>)</syntax>

Returns a procedure that evaluates {{<form>}} with {{_}} bound to its
only argument.

If {{<form>>} is empty, behaves as {{values}}, i.e. the identity function.

{{(op 5)}} is the function that always returns 5.

{{(op + 2 _)}} is the function that adds 2 to its argument.

Note that {{(op (expr))}} can be used as a generator that infinintely
often evaluates {{(expr)}} anew.

<syntax>(op* <form>)</syntax>

Returns a procedure that evaluates {{<form>}} with {{...}} expanded
to all its arguments.  {{...}} must only appear once and must not
be nested further.  If {{...} does not appear in {{<form>}}, it's
added implicitly at the end.

{{(op* + 5)}} is the function that adds 5 and then all its arguments.

{{(op* - 0 ... 2)}} is the function that subtracts all its arguments from 0
and finally 2.

<syntax>(proj <N>...)</syntax>

Expands to a function that returns its {{<N>}}th argument (zero indexed).
Multiple arguments are returned as multiple values.

<procedure>(boolean <obj>)</procedure>

Return false if {{<obj>}} is {{#f}}, and true else.

<procedure>(negate <fun>)</procedure>

Alias for {{complement}}.

<procedure>(comp <fun>...)</procedure>

Alias for {{compose}}.

<procedure>(per <fun>...)</procedure>

Reverse function composition.

<procedure>(act <obj> <fun>...)</procedure>

Reverse function compose all {{<fun>}}, then apply to {{<obj>}}.

<procedure>(=> <obj> <fun>...)</procedure>

Alias for {{act}}.

<syntax>(=>* <form> <fun>...)</syntax>

Like {{=>}}, but {{<form>}} may return multiple values.

<syntax>(set=> <loc> <fun>...)</set>

Shortcut for {{(set <loc> (=> <loc> <fun>...))}}.

<procedure>(and=> <obj> <fun>...)</procedure>

Apply the first function in {{<fun>}} to {{<obj>}}, then the second to
the result, etc.  Stop if any value is false.

<procedure>(juxt <fun>...)</procedure>

Returns a function that applies each {{<fun>}} to its arguments and
returns the results as multiple values.

<procedure>(unlist <list>)</procedure>

Returns the list {{<list>}} as multiple values.

<procedure>(str . <args>)</procedure>

Returns a new string composed by concatenating the strings given by
applying {{display}} to all {{<args>}}.

<syntax>(one-of <val>...)</syntax>

Expands to a lambda expression that is true if its argument is
{{equal?}} to any of the {{<val>}} passed.

<procedure>(sing? <list>)</procedure>

Return true iff {{<list>}} is a proper list of length 1.

<procedure>(void <args>...)</procedure>

Ignores all arguments and returns a value where {{void?}} is true.

<procedure>(void? <val>)</procedure>

Returns true if {{<va>}} is an unspecified value, else false.

<procedure>(scan <kons> <knil> <lists>...)</procedure>
<procedure>(scan-right <kons> <knil> <lists>...)</procedure>

Like {{fold}}/{{fold-right}}, but collects all accumulator values.
Prefer {{xscan}}/{{xscan-right}}.

<procedure>(xfold <kons> <knil> <lists>...)</procedure>
<procedure>(xfold-right <kons> <knil> <lists>...)</procedure>
<procedure>(xreduce <kons> <knil> <lists>...)</procedure>
<procedure>(xreduce-right <kons> <knil> <lists>...)</procedure>
<procedure>(xscan <kons> <knil> <lists>...)</procedure>
<procedure>(xscan-right <kons> <knil> <lists>...)</procedure>

Like {{fold}}/{{fold-right}}/{{reduce}}/{{reduce-right}}/{{scan}}/{{scan-right}},
but {{<kons>}} always takes the accumulator as first arguments,
and the items after.  This is more practical when multiple {{lists}}
are passed.

<syntax>(imp <antedecent>... <consequent>)<syntax>

Material implication: evaluate {{<antedecent>...}} until one is false,
then shortcut and return true.  If all {{<antedecent>...}} are true,
evaluate {{<consequent>}}.


== I/O helpers

<procedure>(prn . <args>)</procedure>

{{write}} all {{args}} separated by spaces and terminated by a newline
to the current output stream.  Returns the value of the last argument.

<procedure>(puts . <args>)</procedure>

{{display}} all {{args}} terminated by a newline to the current output stream.

<procedure>(eof)</procedure>

Return an object for which {{eof-object?}} is true.

<procedure>(slurp <obj>)</procedure>

If {{<obj>}} is an input-port, read all data into a string.
If {{<obj>}} is a string, read all data from the file named {{<<obj>>}.
If {{<obj>}} is false, read all data from {{*current-input-port*}}.


== Equality

<procedure>(=? <val>...)</procedure>

Return true if all values are {{equal?}} or hash-tables with same
set of keys and {{equal?}} values.

<procedure>(<>? <val1> <val2> ...)</procedure>

Return true if all values are pairwise different.


== Data types

<procedure>(get <obj> <idx>)</procedure>
<procedure>(at <obj> <idx>)</procedure>
<procedure>(set (at <obj> <idx>) <val>)</procedure>

Generalized accessor, supports indexing into lists, vectors,
hash-tables, strings.

<procedure>(set-at <obj> <key1> <val1>...)</procedure>

Mutate the hash-table/vector/string {{<obj>}} by setting
the key/index {{<key1>}} to {{<val1>}} etc.
Returns {{<obj>}}.

<procedure>(del-at <hash-table> <key>...)</procedure>

Delete {{<key>}} from the hash-table, and return the hash-table.

<procedure>(tbl <key1> <val1> ... <keyN> <valN>)</procedure>

Construct a hash-table; using {{equal?}}.

<procedure>(keys <hash-table>)</procedure>

Alias for {{hash-table-keys}}.

<procedure>(vals <hash-table>)</procedure>

Alias for {{hash-table-values}}.

<procedure>(empty? <obj>)</procedure>

Test if {{<obj>}} is an empty list/string/vector/hash-table.

<procedure>(len <obj>)</procedure>

Return the length of the list/vector/string/hash-table/generator {{<obj>}}.

<syntax>(for (<var> <obj>) <body>...)</syntax>
<syntax>(for ((<key> . <val>) <tbl>) <body>...)</syntax>

If {{<obj>}} is a list or a vector, iterate over its elements.
If {{<obj>}} is a procedure, consider it a SRFI-158 generator
and iterate over its values.
If {{<obj>}} is a hash-table, iterate over its keys and values.

<procedure>(search <needle> <haystack> <offset>?)</procedure>

Returns the offset of the sequence (string/list/vector) {{<needle>}}
in the sequence {{<haystack>}},
starting no earlier than {{<offset>>}} (default: 0).
Returns false if the sequence cannot be found.


== Generators and Accumulators

<procedure>(gen <val>)</procedure>

Generic generator for list/vector/string/hash-table/generator.

<procedure>(cycle <val>...)</procedure>

Alias for {{circular-generator}}.

<procedure>(range <start>? <end>? <step>?)</procedure>

A variant of {{make-range-generator}} that also allows negative {{<step>}}.
{{<start>}} defaults to zero.
{{<end>}} defaults to infinity.
{{<step>}} defaults to 1.

<procedure>(giterate <fun> <val>)</procedure>

Generator returning {{<val>}}, {{(<fun> <val>)}}, {{(<fun> (<fun (<val>)))}}...

<procedure>(gconcatenate <gen>)</procedure>

Generator yielding all values of the all generators yielded by {{<gen>}}.

<procedure>(gpick <function> <gen>)<procedure>

Like {{gmap}}, apply {{<function>}} to all values yielded by
the generator {{<gen>}}, but skip values when {{<function>}} returns
an eof object.

<procedure>(gwindow <gen> <len>)</procedure>

Generator yielding a sliding window of length {{<len>}} (as a list)
over the values yielded by the generator {{<gen>}}.  Yields never if
the generator yielded fewer than {{<len>}} elements.

<procedure>(gslice-when <pred> <gen>)</procedure>

Partition the elements yielded by the generator {{<gen>}} into lists:
starts a new list when the predicate {{<pred>}} called with the
previous and the current element of the generator returns true.

<procedure>(genumerate <gen>)</procedure>

Takes the values yielded by the generator {{<gen>}} and yields them as
a {{cons}} where the first cell is an index incremented on every
yield.

<procedure>(gfix <gen>)</procedure>

Returns a generator that runs the generator {{<gen>}} until it yields
a value {{equal?}} to the preceding one, then stops.

<procedure>(final <gen>)</procedure>

Run the generator {{<gen>}} until it stops and return its final value.

<procedure>(into <acc> <gen>...)</procedure>

Feed all elements of the generators {{<gen>}} into the accumulator {{<acc>}}.
Uses {{gen}} to convert {{<gen>}} into a generator.
If {{<acc>}} is a list/vector/hash-table/string, accumulate into
a corresponding accumulator initialized to {{<acc>}}.

<syntax>(accumulate (<var> <acc>) body ...)</syntax>

Bind {{<var>}} to the accumulator {{<var>}} and run {{body}}.
Finally, return the result of accumulation.
If {{<acc>}} is a list/vector/hash-table/string, accumulate into
a corresponding accumulator initialized to {{<acc>}}.

<procedure>(tally-accumulator)</procedure>

Returns an accumulator that counts how often each element was
accumulated.  The accumulator results in a hash-table of objects to
numbers.

<procedure>(group-by-accumulator <f>)</procedure>

Returns an accumulator that stores all elements in lists in a hash-table,
applying {{<f>}} to the element to compute the key.

<procedure>(uniq-accumulator <f>?)</procedure>

Returns an accumulator that returns a list of unique elements.
Two elements are considered equal if their image under {{<f>}} is {{equal?}}.
{{<f>}} defaults to the identity function.

<procedure>(generator-xfold <f> <seed> <generators>...)</procedure>

Like {{generator-fold}}, but {{<f>}} always takes the accumulator as
first arguments, and the items after.  This is more practical when
multiple {{<generators>}} are passed.

<procedure>(inject <f> <init>? <g>?)</procedure>

Returns a procedure that takes an generator (or something convertible
by {{gen}}) and xfolds the function {{<f>}} over its values.  If given,
folding starts with {{<init>}}, else with the first element yielded by
the generator.  If the generator is empty, return {{(<f>)}}.
If {{<g>}} is passed, immediately fold over the generator {{<g>}}.

<procedure>(odometer <wheels>...)</procedure>

Returns a generator that takes a list of numbers and yields all
combinations of numbers such that each is below it's wheel.  The
rightmost number changes most quickly.

<procedure>(cross-product <obj>...)</procedure>

Returns a generator that takes multiple lists/vectors/strings and
yields all elements of their cartesian product (as lists).


== Regular expressions

<procedure>(?~ <str> <irx>)</procedure>

Matches the string {{<str>}} against the irregex (string or sexp) {{<irx>}}
without anchoring.  Returns false on no match, else a list of all
match data strings.

<procedure>(gmatch <irx> <str>)</procedure>

Returns a generator that for each match of the irregex {{<irx>}} in
the string {{<str>}} either yields the match, or a list of all
match data strings (if there are any).

<procedure>(gsplit <irx> <str> <max>?)</procedure>

Returns a generator that yields the strings between matches of the
irregex {{<irx>}} in the string {{<str>}}, at most {{<max>>} times
(by default, unlimited).

When the pattern {{<irx>}} uses match data, the result is unspecified.


== Random numbers

Mew initializes the {{(chicken random)}} generator from a high entropy source.

<procedure>(rand)</procedure>

Returns a random real between 0 and 1.

<procedure>(rand <N>)</procedure>

Returns a random integer such that 0 <= {{(rand <N>)}} < {{<N>}}.

<procedure>(rand <N> <M>)</procedure>

Returns a random integer such that N <= {{(rand <M>)}} < {{<M>}}.

<procedure>(shuffle <vector>)</procedure>

Returns a copy of the vector {{<vector>}} with the entries in randomized order.

<procedure>(shuffle! <vector>)</procedure>

Shuffles the vector {{<vector>}} randomly in-place using a Fisher-Yates shuffle.

<procedure>(sample <obj>)</procedure>

Returns a random element of the list/vector/string {{<obj>}}.
Returns a random key/value pair of the hash-table {{<obj>}}.

<procedure>(sample <obj> <N>)</procedure>

Returns a random list/vector/string consisting of up to {{<N>}}
elements of the list/vector/string {{<obj>}}, without replacement.

Returns a random hash-table consisting of up to {{<N>}} key/value
pairs of the hash-table {{<obj>}}, without replacement.


== Special syntax

<syntax>(-> a -> b c -> d e f)</syntax>
<syntax>(-> a ->> b c ->> d e f)</syntax>

Nesting macros: {{->}} inserts the previous part as the second argument:
{{(-> a -> b c -> d e f)}} expands to {{(d (b a c) e f)}}.

{{->>}} inserts the previous part as the last argument:
{{(-> a ->> b c ->> d e f)}} expands to {{(d e f (b c a))}}.

You can mix {{->}} and {{->>}} macros:
{{(-> a -> b c ->> d e f)}} expands to {{(d e f (b a c))}}.

Nesting macros must start off with a {{->}}.

<syntax>(fun-> b c -> d e f)</syntax>
<syntax>(fun->> b c ->> d e f)</syntax>

Nesting lambdas: like {{->}} but the nesting starts with the argument
of the lambda.
{{(fun-> b c -> d e f)}} expands to {{(lambda (x) (-> x -> b c -> d e f))}}.
{{(fun->> b c ->> d e f)}} expands to {{(lambda (x) (-> x ->> b c ->> d e f))}}.

<syntax>(set-> loc ...)</syntax>

Mutation with nesting macros: shortcut for {{(set loc (-> loc ...))}}.

<syntax>(-> ... if-> <val> <cond> <then> <else>?)<syntax>

Evaluate {{<val>}}.  Then, when {{<cond>}} is not false, behaves like
{{(-> <val> -> <then>}}, otherwise like {{(-> <val> -> <else>)}}
(or just {{<val>}} if no {{<else>}} was passed).

<syntax>(-> ... and-> ...)<syntax>
<syntax>(-> ... and->> ...)<syntax>

Like {{->}}/{{->>}} but skips nesting the code if the nested
expression is false.

<syntax>(-> ... ok-> ...)<syntax>
<syntax>(-> ... ok->> ...)<syntax>

Like {{->}}/{{->>}} but skips nesting the code if the nested
expression is {{err?}}.

<syntax>(-> ... err-> ...)<syntax>
<syntax>(-> ... err->> ...)<syntax>

Like {{->}}/{{->>}} but skips nesting the code if the nested
expression is {{ok?}}.  The unwrapped value is inserted into the nesting.
